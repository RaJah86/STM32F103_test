/////////////////////////////////////////////////////////////////////////
//
//										 OLED_Mono_128x64.c
//										(OLED_Mono_128x64.h)
//		Работа с монохромным OLED 128x64. 
//
//		Foton6
//		13.02.2017
//
/////////////////////////////////////////////////////////////////////////

#include "OLED_Mono_128x64.h"


//____Буффер экрана
//
//		Содержит полный набор данных для вывода на дисплей.
//		Бальшенство функций описанных выше работают с данным буффером а
//		не сдисплеем на прямую.
//
//		Экран размером 128*64, байты выводятся 
//		"вертекально" - 64/8 = 8 строк по 8 бит.
//
uint8_t OLED_BuffOut[8][128] = {0x00};	



//____Структура для работы с I2C
//
//		Содержит данные о выводимом буффере и адресс дисплея.
//
//		AdrSlave	= 0		(устанавливается при инициализации).
//		ByteNum		= ****	
//		*AdrData	= OLED_BuffOut
//		DataLen 	= 1024
//
//
I2CStruct OLED = {0, 0, &OLED_BuffOut[0][0], 1024};

////////////////////////////////////////////////////////////////////////////

uint8_t Sym_0[6] = {0x3E, 0x51, 0x49, 0x45, 0x3E, 0x00};				//__0.
uint8_t Sym_1[4] = {0x00, 0x42, 0x7F, 0x40};										//__1.
uint8_t Sym_2[6] = {0x42, 0x61, 0x51, 0x49, 0x46, 0x00};				//__2.
uint8_t Sym_3[6] = {0x21, 0x41, 0x45, 0x4B, 0x31, 0x00};				//__3.
uint8_t Sym_4[6] = {0x18, 0x14, 0x12, 0x7F, 0x10, 0x00};				//__4.
uint8_t Sym_5[6] = {0x27, 0x45, 0x45, 0x45, 0x39, 0x00};				//__5.
uint8_t Sym_6[6] = {0x3C, 0x4A, 0x49, 0x49, 0x30, 0x00};				//__6.
uint8_t Sym_7[6] = {0x01, 0x79, 0x09, 0x05, 0x03, 0x00};				//__7.
uint8_t Sym_8[6] = {0x36, 0x49, 0x49, 0x49, 0x36, 0x00};				//__8.
uint8_t Sym_9[6] = {0x06, 0x49, 0x49, 0x29, 0x1E, 0x00};				//__9.
uint8_t Sym_A[6] = {0x7E, 0x09, 0x09, 0x09, 0x7E, 0x00};				//__A.
uint8_t Sym_B[6] = {0x7F, 0x49, 0x49, 0x49, 0x36, 0x00};				//__B.
uint8_t Sym_C[6] = {0x3E, 0x41, 0x41, 0x41, 0x22, 0x00};				//__C.
uint8_t Sym_D[6] = {0x7F, 0x41, 0x41, 0x22, 0x1C, 0x00};				//__D.
uint8_t Sym_E[6] = {0x7F, 0x49, 0x49, 0x49, 0x41, 0x00};				//__E.
uint8_t Sym_F[6] = {0x7F, 0x09, 0x09, 0x09, 0x01, 0x00};				//__F.
uint8_t Sym_x[6] = {0x44, 0x28, 0x10, 0x28, 0x44, 0x00};				//__x.
uint8_t Sym_Minus[6] = {0x08, 0x08, 0x08, 0x08, 0x08, 0x00};		//__-.
uint8_t Sym_Plus[6] = {0x08, 0x08, 0x3E, 0x08, 0x08, 0x00};			//__+.

SymbolType HexSym[19] = 
{{	6,	8,	Sym_0},	{	4,	8,	Sym_1},	{	6,	8,	Sym_2},	{	6,	8,	Sym_3},
{		6,	8,	Sym_4},	{	6,	8,	Sym_5},	{	6,	8,	Sym_6},	{	6,	8,	Sym_7},
{		6,	8,	Sym_8},	{	6,	8,	Sym_9},	{	6,	8,	Sym_A},	{	6,	8,	Sym_B},
{		6,	8,	Sym_C},	{	6,	8,	Sym_D},	{	6,	8,	Sym_E},	{	6,	8,	Sym_F},
{		6,	8,	Sym_x},	{	6,	8,	Sym_Minus},	{	6,	8,	Sym_Plus}};

////////////////////////////////////////////////////////////////////////////

uint8_t MedusaBuff [3][10] = 
	{	
		0xC0, 0xC0, 0xF0, 0xF0, 0xFC, 0x9C, 0x9F, 0xE7, 0xE7, 0xFF,
		0x03, 0x03, 0xFF, 0xFF, 0x03, 0x03, 0xFF, 0xFF, 0x03, 0x03,
		0x00, 0x00, 0x03, 0x03, 0x00, 0x00, 0x03, 0x03, 0x00, 0x00,
	};
	
SymbolType Medusa = {10, 24, &MedusaBuff[0][0]};	

////////////////////////////////////////////////////////////////////////////


///////////////////////____Инициализация OLED____///////////////////////////////
//
//	Функция ррасчитана на работу без прерываний и ДМА!!!
//
//	Подходит не ковсем дисплеям, так как направление строк и столбцов 
//  может отличатся. Если вывод данных происходит не коррекно, то необходимо
//	поигратся с настройками дисплея, а в частности с ремапингом столбов и строк.
//
//	AdrSlave - адресс дисплея на шине I2C.
//
/////////////////////////////////////////////////////////////////////////////////
void OLED_Init	(uint8_t AdrSlave)
{
	OLED.AdrSlave = AdrSlave;			//__Установка адресса дисплея.
	
	OLED_SendByte (0xA8, 1);			//__64 строки
	OLED_SendByte (0x3F, 1);			//
	
	OLED_SendByte (0x20, 1);			//__Режим адрессации
	OLED_SendByte (0x00, 1);			//

	OLED_SendByte (0xA1, 1);			//__Ремап столбцов (127...0).
	
	OLED_SendByte (0xC8, 1);			//__Ремап строк (63...0).
	
	OLED_SendByte (0x81, 1);			//__Контрастность.
	OLED_SendByte (0xCF, 1);			//

	OLED_SendByte (0x8D, 1);			//__ON display
	OLED_SendByte (0x14, 1);			//
	OLED_SendByte (0xAF, 1);			//
	
	OLED_SendByte (0x21, 1);			//__0 столб стартовый, 127 последний.
	OLED_SendByte (0, 1);					//
	OLED_SendByte (127, 1);				//
	
	OLED_SendByte (0x22, 1);			//__0 строка стартовая, 7 последняя.
	OLED_SendByte (0, 1);					//
	OLED_SendByte (7, 1);					//
	
	OLED_Clear();
}

///////////////////////____Очистка OLED____/////////////////////////
//
//	Функция ррасчитана на работу без прерываний и ДМА!!!
//
/////////////////////////////////////////////////////////////////////
void OLED_Clear (void)
{
	uint16_t i;
	d_I2C_Start();											//__Старт.
	while(!d_StartEnd);
		
	d_I2C_Byte(OLED.AdrSlave);					//__Адрес дисплея.
	while(!d_AdrSendEnd);
	d_I2C_SR2_Clear();										//__Чтение регистра для очистки в нем флагов!

	d_I2C_Byte(0x40);										//__data
	
	for(i = 0; i < 1024; i++)
	{
		d_I2C_Byte(0x00);
		while(!d_ByteSendEnd);	
	}

	d_I2C_Stop();												//__Стоп.
	while(I2C1->SR2 & I2C_SR2_BUSY);	
}

/////////////////////////____Очистка части OLED дисплея____/////////////////////////////
//
//	Функция ррасчитана на работу с прерываниями или ДМА!
//	Функция модифицирует буффер, который в последствии целиком выводится на дисплей.
//	Так же требует выдачи команды СТАРТ после выполнения, это позволяет
//	сначала провести несколько операций с буффером а затем сформировать старт.
//	
//	Координаты XY это координаты верхнего левого пикселя начала очистки:
//	X - по горизонтали адрессация (0 - 127)
//	Y - по вертикали адрессация	(0 - 63)
//	
//	Hight - высота очищаемого фрагмента
//	Width - ширина очищаемого фрагмента
//
///////////////////////////////////////////////////////////////////////////////////////
void OLED_ClearXY(uint8_t X, uint8_t Y, uint8_t Hight, uint8_t Width)
{
	uint8_t i, ii;
	uint8_t OffsetY = (Y - ((uint8_t)(Y >> 3) << 3));
	
	if(OffsetY > 0)
		Hight = ((Hight >> 3) + 1);
	else
		Hight = Hight >> 3;		

	Y = Y >> 3;
	
	for(i = 0; i < Hight; i++)
	{
		for(ii = 0; ii < Width; ii++)
		{			
			OLED_BuffOut[Y+i][X+ii] = 0x00;	
		}			
	}	
}

/////////////////////____Отправка байта OLED дисплею____////////////////////////////
//
//	Функция ррасчитана на работу без прерываний и ДМА!!!
//
//	data - данные для отправки.
//	mod -  0 - данные
//				 1 - команда
//
///////////////////////////////////////////////////////////////////////////////////
void OLED_SendByte (uint8_t data, uint8_t mod)
{
	d_I2C_Start();						//__Старт.
	while(!d_StartEnd);
		
	d_I2C_Byte(OLED.AdrSlave);				//__Адрес дисплея.
	while(!d_AdrSendEnd);
	d_I2C_SR2_Clear();					//__Чтение регистра для очистки в нем флагов!
		
	if(mod)
		d_I2C_Byte(0x00);				//__cmd
	else
		d_I2C_Byte(0x40);				//__data	
	while(!d_ByteSendEnd);

	d_I2C_Byte(data);					//__data	
	while(!d_ByteSendEnd);

	d_I2C_Stop();							//__Стоп.
	while(d_I2C_WaitBusy);		
}

//////////////____Отправка последовательности байт OLED дисплею____/////////////////
//
//	Функция ррасчитана на работу без прерываний и ДМА!!!
//
//	data 		- указатель на массив байт для отправки
//	LenMsg 	- колличество байт для отправки
//	mod 		-  0 - данные
//						 1 - команды
//
///////////////////////////////////////////////////////////////////////////////////
void OLED_Send (uint8_t* Data, uint16_t LenMsg, uint8_t Mod)
{
	uint16_t i;
	
	d_I2C_Start();						//__Старт.
	while(!d_StartEnd);
		
	d_I2C_Byte(OLED.AdrSlave);			//__Адрес дисплея.
	while(!d_AdrSendEnd);
	d_I2C_SR2_Clear();					//__Чтение регистра для очистки в нем флагов!
	
	if(Mod)
		d_I2C_Byte(0x00);				//__cmd
	else
		d_I2C_Byte(0x40);				//__data	
	
	while(!d_ByteSendEnd);

	for(i = 0; i < LenMsg; i++)
	{
		d_I2C_Byte(Data[i]);
		while(!d_ByteSendEnd);	
	}

	d_I2C_Stop();							//__Стоп.
	while(d_I2C_WaitBusy);		
}

///////////////////////____Отправка символа OLED дисплею____////////////////////////////
//
//	Функция ррасчитана на работу с прерываниями или ДМА!
//	Функция модифицирует буффер, который в последствии целиком выводится на дисплей.
//	Так же требует выдачи команды СТАРТ после выполнения, это позволяет
//	сначала провести несколько операций с буффером а затем сформировать старт.
//	
//	Координаты XY это координаты верхнего левого пикселя:
//	X - по горизонтали адрессация (0 - 127)
//	Y - по вертикали адрессация	(0 - 63)
//	
//	Data - указатель на структуру необходимого символа. Структура
//					типа SymbolType.
//
//	Mirror - позволяет зеркаллировать символ по вертикальной оси
//						0 - нормальный вывод
//						1 - зеркалирование
//		
///////////////////////////////////////////////////////////////////////////////////////
void OLED_SendSym (uint8_t X, uint8_t Y, SymbolType *Data, uint8_t Mirror)
{
	uint8_t i, ii;
	uint8_t temp;
	uint8_t Hight;
	uint8_t Width;
	uint8_t OffsetY = (Y - ((uint8_t)(Y >> 3) << 3));
	
	if(OffsetY > 0)
		Hight = ((Data->Hight >> 3) + 1);
	else
		Hight = Data->Hight >> 3;		

	Width = Data->Width;
	Y = Y >> 3;
		
	for(i = 0; i < Hight; i++)
	{
		for(ii = 0; ii < Data->Width; ii++)
		{
			temp = 0;
	
			if(i > 0)
				temp = ((Data->Symbol[(i - 1)*Width+ii]) >> (8 - OffsetY));
			
			if(i < (Data->Hight >> 3))
				temp |= ((Data->Symbol[i*Width+ii]) << OffsetY);
			
			if(Mirror == 0)
				OLED_BuffOut[Y+i][X+ii] = temp;	
			else
				OLED_BuffOut[Y+i][X+Data->Width-ii-1] = temp;					
		}			
	}
}
///////////////////////////////////////////////////////////////////////////////

/////////////////////////____Вывод данных в HEX формате____/////////////////////////////
//
//	Функция ррасчитана на работу с прерываниями или ДМА!
//	Функция модифицирует буффер, который в последствии целиком выводится на дисплей.
//	Так же требует выдачи команды СТАРТ после выполнения, это позволяет
//	сначала провести несколько операций с буффером а затем сформировать старт.
//	
//	Координаты XY это координаты верхнего левого пикселя строки:
//	X - по горизонтали адрессация (0 - 127)
//	Y - по вертикали адрессация	(0 - 63)
//	
//	Data - данные для вывода
//	Len - число отображаемых полубайт! Не более 8!
//
//	Пример вывода (ознакомится внимательно!):    
//			OLED_OutHex(0, 0, 0x1D5E, 2);
//
//	на дисплее в самом начале (вверху слева) появится:
//			0xE5
//
///////////////////////////////////////////////////////////////////////////////////////
void OLED_OutHex(uint8_t X, uint8_t Y, uint32_t Data, uint8_t Len)
{
	uint8_t temp, i;	
	
	temp = 128 - (6 * (Len + 2));
	if((X < temp) && (Y < 56))
	{
		OLED_SendSym (X, Y, &HexSym[0],  0);			//__0.
		OLED_SendSym (X + 6, Y, &HexSym[16], 0);	//__x (0x).
	}
	else
		return;
	
	if(Len > 8)
		Len = 8;
	
	X+=12;
	
	for(i = 0; i < Len; i++)
	{
		temp = ((Data >> ((Len - 1) * 4)) & 0x0F);
		OLED_ClearXY((X + (i * 6)), Y, 8, 8);
		OLED_SendSym((X + (i * 6)), Y, &HexSym[temp],  0);
		Data = Data << 4;
	}
}

/////////////////////////____Вывод данных в DEC формате____/////////////////////////////
//
//	///	####  ЖУТКИЙ КОЛХОЗ, аж ПЗДЦ!!!!! Переделать как будет время.
//
//	Функция ррасчитана на работу с прерываниями или ДМА!
//	Функция модифицирует буффер, который в последствии целиком выводится на дисплей.
//	Так же требует выдачи команды СТАРТ после выполнения, это позволяет
//	сначала провести несколько операций с буффером а затем сформировать старт.
//	
//	Координаты XY это координаты верхнего левого пикселя строки:
//	X - по горизонтали адрессация (0 - 127)
//	Y - по вертикали адрессация	(0 - 63)
//	
//	Data - данные для вывода
//	
///////////////////////////////////////////////////////////////////////////////////////
void OLED_OutDec(uint8_t X, uint8_t Y, uint32_t Data)	///	####  ЖУТКИЙ КОЛХОЗ, аж ПЗДЦ!!!!!
{
	uint8_t temp, temp2, i;	
		
	temp = 128 - (6 * 4);
	if((X > temp) && (Y > 56))
		return;
	
	temp = (uint8_t)Data;
	
	if(temp & 0x80)
		Data = 17;		//__ '-'.
	else
		Data = 18;		//__ '+'.
	
	temp &= ~0x80;
	if(temp > 0)
	{
		if(temp > 99)
		{		
			temp2 = temp / 100;
			Data <<= 8;
			Data |= temp2;
			
			temp -= temp2 * 100;
			temp2 = temp / 10;
			Data <<= 8;
			Data |= temp2;

			temp -= temp2 * 10;		
			Data <<= 8;
			Data |= temp;
			temp = 0;
		}
		if(temp > 9)
		{
			temp2 = temp / 10;
			Data <<= 8;
			Data |= temp2;

			temp -= temp2 * 10;		
			Data <<= 8;
			Data |= temp;
			temp = 0;
		}
		if(temp > 0)
		{
			Data <<= 8;
			Data |= temp;
		}
	}
	else
		Data = 0;
	
	for(i = 0; i < 4; i++)
	{
		temp = ((Data >> (8 * (3 - i)))& 0xFF);
		OLED_ClearXY((X + (i * 6)), Y, 8, 8);
		if(temp > 0 || i == 3)
			OLED_SendSym((X + (i * 6)), Y, &HexSym[temp],  0);
		if((Data >> (8 * (4 - i)))& 0xFF)
			OLED_SendSym((X + (i * 6)), Y, &HexSym[temp],  0);
	}
}

/////////////////////////____Вывод данных в BIN формате____/////////////////////////////
//
//	Функция ррасчитана на работу с прерываниями или ДМА!
//	Функция модифицирует буффер, который в последствии целиком выводится на дисплей.
//	Так же требует выдачи команды СТАРТ после выполнения, это позволяет
//	сначала провести несколько операций с буффером а затем сформировать старт.
//	
//	Координаты XY это координаты верхнего левого пикселя строки:
//	X - по горизонтали адрессация (0 - 127)
//	Y - по вертикали адрессация	(0 - 63)
//	
//	Data - данные для вывода
//	
///////////////////////////////////////////////////////////////////////////////////////
void OLED_OutBin(uint8_t X, uint8_t Y, uint8_t Data)
{
	uint8_t temp, i;	
	
	temp = 128 - (6 * 8);
	if((X > temp) && (Y > 56))
		return;

	for(i = 0; i < 8; i++)
	{
		temp = ((Data >> (7 - i)) & 0x01);
		OLED_ClearXY((X + (i * 6)), Y, 8, 8);
		OLED_SendSym((X + (i * 6)), Y, &HexSym[temp], 0);
	}
}


///////////////////////////////////////////////////////////////////////////////

